# Конспект Лекции 1: «Сложность, тестирование, особые случаи»

## Что такое сложность?

* Сложность алгоритма — порядок количества действий, которые выполняет алгоритм
* Например, в прогромме два вложенных цикла, каждый от 1 до N, тогда сложность составляет O(N^2)
* 100*N = O(N), 2N = O(N). Здесь 100 и 2 — константы на зависящие от размера входных данных. Константы не так сильно
  влияют на скорость работы алгоритма при больших параметрах
* Еще бывает "пространственная сложность" — количесто использованной памяти

## Задача 1

> **Дана строка в кодировке UTF-8**
>
> Найти самый часто встречающийся в ней символ. Если несколько символов встречаются одинаково часто вывести любой.

### Решение 1

> Перебираем все позиции и для каждой позиции в строке еще раз переберем все позиции и случае совпадения прибавим к счетчику единицу. Найдем максимальне значение счётчика

Time Complexity O(N^2)

Memory Complexity O(N)

```py
s = input()
ans = ''
anscnt = 0
for i in range(len(s)):
    nowcnt = 0
    for j in range(len(s)):
        if s[i] == s[j]:
            nowcnt += 1
    if nowcnt > anscnt:
        ans = s[j]
        anscnt = nowcnt
print(ans)
```

### Решение 2

> Перебираем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальне значение счётчика

Time Complexity O(NK)

Memory Complexity O(N + K) = O(N)

```py
s = input()
ans = ''
anscnt = 0
for i in set(len(s)):
    nowcnt = 0
    for j in range(len(s)):
        if s[i] == s[j]:
            nowcnt += 1
    if nowcnt > anscnt:
        ans = s[j]
        anscnt = nowcnt
print(ans)
```

### Решение 3

> Заведём словарь, где ключом является символ,
> а значение — сколько раз он встретился.
> Если символ встретился впервые — создаем элемент словаря с ключом, совпадающим с этим символом и значением ноль. Прибавляем к элементу словаря с ключом, совпадающем с этим символом, единицу.

Time Complexity O(N + K) = O(N)

Memory Complexity O(K)

```py
s = input()
ans = ''
anscnt = 0
dct = {}
for now in s:
    if now not in dct:
        dct[now] = 0
    dct[now] += 1
for key in dct:
    if dct[key] < anscnt:
        anscnt = dct[key]
        ans = key
print(ans)
```

## Что нужно протестировать? (В голове)

* Тесты из условия
* Общие случаи
* Особые случаи

## Советы по составлению тестов

* Если есть примеры — реши их руками и сверь ответ. Если не совпадает, то либо правильным ответов может быть несколько,
  либо ты неправильно понял задачу
* Сначала составь несколько примеров и реши задачу руками, чтобы лучше понять условие и чтобы потом было с чем сравнить
* Проверь последовательность из одного элемента и пустую последовательность
* «Краевые эффекты» — проверь, что программа работает корректно в начале и конце последовательности, сделай тесты, чтобы
  ответ находился на первом и на последнем месте в последовательности
* Составь покрытие всех ветвпений, так чтобы был тест, который входит в каждый ```if``` и ```else```
* Подбери тесты чтобы не было ни одного входа в цикл
* Один тест — одна возможная ошибка

## Покрытие тестами

> Задача даны три целых числа a, b, c.
> Найдите все корни уравнении ```aх^2 * bx * c = 0``` и выведите их в порядке возрастания

### Спустя 8 попыток приходим к правильному решени.

```py
if a == 0:
    if b != 0:
        print(-c / b)
    if b == 0 and c == 0:
        print("Infinite number of solutions")
else:
    d = b ** 2 - 4 * a * c
    // print(sqrt(d))
    if d == 0:
        x1 = -b / (2 * a)
        print(x1)
    elif d > 0:
        x1 = (-b - sqrt(d)) / (2 * a)
        x2 = (-b + sqrt(d)) / (2 * a)
        if x1 < x2:
            print(x1, x2)
        else:
            print(x2, x1)
```