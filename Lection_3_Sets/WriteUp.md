# Конспект Лекции 3: «Множества»

## Что должно уметь множество?

* Добавлять элемент
* Проверять наличие элемента
* Удалять элемент

## Как устроено множество?

* Придумаем какую-нибудь функцию, которая сопоставляет каждому элементу какое-либо небольшое число
* Вычислим функцию от элемента
* Положим элемент в список с номером, равным значению функции

Удаление элемента O(1)
Поиск элемента O(K/N)

## Собственное (мулти)множество

```py
setsize = 10
myset = [[] for _ in range(setsize)]


def add(x):
    myset[x % setsize].append(x)


def find(x):
    for now in myset[x % setsize]:
        if now == x:
            return True
    return False


def delete(x):
    xlist = myset[x % setsize]
    for i in range(len(xlist)):
        if xlist[i] == x:
            xlist[i], xlist[len(xlist) - 1] = xlist[len(xlist), xlist[i]
            xlist.pop()
            return 
```

## Что можно хранить в множестве эффективно?

* Только **неизменяемые** объекты
* Для неизменяемых объектов можно посчитать значение хеш-функции при их создании.
* Хеш-функция должна давать равномерное распределение

## Проблемы с хеш-таблицей

* Слишком большой размер — ест много памяти ```O(N)```
* Слишком маленький размер — большой коэффициент заполнения и медленный поиск и удаление ```O(K/N)```
* Хочется иметь разумный баланс, например, коэффициент заполнения не больше единицы ```(т.е. K <= N)```
  Тогда все операции в среднем будут занимать ```O(1)```

## Решение

Увеличение размера хеш-таблицы в двое.

## Амортизированная сложность

* Амортизированная сложность — среднее время выполнения операции (условно)
* У нас амортизированная сложность операции ```O(1)``` — всего было ```N``` операций и суммарно ушло ```O(N)```
* В худшем случае отдельная операция выполняется за ```O(N)``` — может не происходить в системах реального времени

## Задача 1

> Дана последоавательность положительных чисел длинной N и число X
>
> Нужно найти два различных числа A и B из последовательности, таких что A + B = X
> или вернуть пару 0, 0, если такой пары чисел нет

### Решение за O(N^2)

> Перебираем число A за O(N). Перебираем число B за O(N).
> Если их сумма равна X, вернем эту пару

```py
def twoTermsWithSumX(nums, x):
    for i in range(len(nums) - 1):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == x:
                return nums[i], nums[j]
    return 0, 0
```

### Решение за O(N)

> Будем хранить все уже обработанные числа в множестве.
> Если очередное число nownum, а X — nownum есть в множестве, то мы нашли слагаемые

```py
def twoTermsWithSumX(nums, x):
    prevnums = set()
    for num in nums:
        if x - nownum in prevnums:
            return nownum, x - nownum
        prevnums.add(nownum)
    return 0, 0
```

## Задача 2

> Дан словарь из N слов, длинна каждого не превосходит K
>
> В записи каждого из M слов текста (каждое длинной K) может быть пропущена одна буква.
> Для каждого слова сказать, входит ли оно (возможно, с одной пропущенной буквой) в словарь

### Решение за O(NK + M)

> Выбросим из каждого слова словаря по одной букве всеми возможными способами за O(NK)
> и положим получившиеся слова в множество.
>
> Для каждого слова из текста проверим, есть ли оно в словаре за O(1)

```py
def wordsInDict(dictionary, text):
    goodwords = set(dictionary)
    for word in dictionary:
        for delpos in range(len(word)):
            goodwords.add(word[:delpos] + word[delpos + 1:])
    ans = []
    for word in text:
        ans.append(word in goodwords)
    return ans
```